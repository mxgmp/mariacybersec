<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>The Silent SIEM: Why Data ≄ Detection</title>
  <meta name="description" content="A Post-Mortem on Stateless Logic, Schema Drift & Correlation Failure.">
  <style>
    :root{ 
      --bg:#000000; --fg:#ffffff; --muted:#6b7280; 
      --accent:#e879f9; --card:#2a2a2a; --border:#2a2a2a; 
    }
    html,body{
      margin:0; padding:0; background:var(--bg); color:var(--fg);
      font:15px/1.7 Helvetica, "Helvetica Neue", Arial, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    .container{ max-width:860px; margin:32px auto 80px; padding:0 16px; }

    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }

    header{ padding:16px 0; }
    .back{ font-size:14px; color:var(--muted); }

    h1 {
      font-family: "Avenir Next", Avenir, Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: var(--accent);
    }
    h2 {
      font-family: "Avenir Next", Avenir, Montserrat, "Helvetica Neue", Helvetica, Arial, sans-serif;
      color: var(--muted);
    }
    p, li {
      font-family: "Source Code Pro", "Courier New", monospace;
      font-size: 15px;
      line-height: 1.6;
      color: #ffffff;
    }
    .highlight { color: var(--accent); font-weight: 600; }
    code {
      background: var(--card);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: "Source Code Pro", "Courier New", monospace;
      color: var(--accent);
    }
    pre { 
      background: #4a4a4a;
      padding: 16px; 
      border-radius: 8px; 
      border: 1px solid var(--border); 
      overflow-x: auto; 
      margin: 16px 0; 
    }
    pre .eql-label {
      color: #ffffff;
      font-weight: 700;
    }
    pre code { 
      background: transparent; 
      padding: 0; 
      color: var(--accent);
      font-weight: 500;
    }
    ul{ margin:8px 0 16px 20px; }
    hr{ border:0; border-top:1px solid var(--border); margin:24px 0; }

    /* gallery + lightbox */
    .muted-text{ color:var(--muted); }
    .project-gallery{ margin-top:28px }
    .project-gallery h2{ color:var(--muted); margin-bottom:6px }
    .img-grid{
      display:grid;
      grid-template-columns:repeat(auto-fill,minmax(230px,1fr));
      gap:14px;
    }
    .img-grid figure{ margin:0 }
    .img-grid img{
      width:100%; height:auto; display:block; border-radius:10px;
      border:1px solid rgba(232,121,249,.25);
      box-shadow:0 4px 15px rgba(0,0,0,.25);
      cursor:zoom-in; transition:transform .2s ease, box-shadow .2s ease;
    }
    .img-grid img:hover{ transform:scale(1.04); box-shadow:0 8px 28px rgba(232,121,249,.4) }

    .lightbox{
      position:fixed; inset:0; display:none; place-items:center;
      background:rgba(0,0,0,.82); z-index:9999; padding:22px;
    }
    .lightbox.open{ display:grid }
    .lightbox img{
      max-width:min(1200px,92vw); max-height:86vh; border-radius:12px;
      box-shadow:0 10px 40px rgba(0,0,0,.6);
    }
    .lightbox .close{
      position:absolute; top:12px; right:16px; font-size:28px;
      color:#fff; cursor:pointer; line-height:1
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <a class="back" href="/" aria-label="Back to home">← mariacybersec</a>
    </header>

    <main class="post">
      <h1>The Silent SIEM: Why Data ≄ Detection</h1>

      <p><strong>A Post-Mortem on Stateless Logic, Schema Drift & Correlation Failure</strong></p>

      <p>SOC failures are rarely caused by missing tools or broken ingestion. More often, they happen when logic, schema, and execution reality drift apart. In this project, I investigated why enabled and "healthy" Elastic Security detections failed to trigger during a simulated Linux intrusion chain, despite telemetry being present. The outcome was a clear reminder of a core detection engineering truth: <span class="highlight">Data existing ≠ detection working.</span></p>

      <h2>1: Telemetry Validation (Is the pipeline blind?)</h2>
      <p>Before testing detection logic, I validated ingestion end-to-end. Elastic Agent status: <span class="highlight">Healthy</span>. Endpoint telemetry ingestion: <span class="highlight">Successful</span>. Observed events included process execution (e.g., <code>whoami</code>) and outbound network activity (e.g., <code>curl</code>). Data was present in the <code>logs-endpoint.events.*</code> data stream.</p>
      <p>Conclusion: the SIEM was not blind. The data existed.</p>

      <h2>2: Attack Simulation (Does behavior produce signals?)</h2>
      <p>I executed a basic post-exploitation workflow to simulate a small intrusion chain:</p>
      <ul>
        <li><span class="highlight">Identity:</span> SSH authentication</li>
        <li><span class="highlight">Discovery:</span> execution of <code>whoami</code></li>
        <li><span class="highlight">Network activity:</span> outbound <code>curl</code> request</li>
      </ul>
      <p>Each behavior occurred at the OS level and produced telemetry. Result; zero alerts.</p>

      <h2>3: Root Cause Analysis (Why the detections stayed silent)</h2>
      
      <p><span class="highlight">1) Schema Mismatch:</span> The SSH brute-force rule queried <code>system.auth</code>. A Dev Tools audit showed that the dataset never initialized; logs existed, but not in the schema the rule assumed. Lesson: a detection rule is only as effective as the data model it relies on.</p>

      <p><span class="highlight">2) Field Semantic Brittleness:</span> One process-based detection expected a specific parent executable. However, actual telemetry reflected different execution semantics (the shell interpreter instead). The detection failed not because the behavior was absent, but because the rule's assumptions didn't match real OS execution behavior.</p>

      <p><span class="highlight">3) Stateless Evaluation:</span> Identity, process, and network telemetry existed, but remained siloed. Without state, time correlation, or entity linking, the SIEM evaluated each signal as low-fidelity noise. The system saw events; but it did not understand behavior.</p>

      <h2>4: Engineering the Fix (Stateful EQL Correlation)</h2>
      <p>To close the gap, I attempted to replace point-in-time detections with a stateful <span class="highlight">EQL sequence</span>. Instead of alerting on individual events, the goal was to correlate a temporal chain:</p>

<pre><span class="eql-label">EQL</span>
<code>sequence by host.name, user.name with maxspan=15m
  [authentication where event.outcome == "success"]
  [process where process.name == "whoami"]
  [network where destination.port == 80]</code></pre>

      <p>The logic is straightforward: when the chain is linked, isolated noise becomes a coherent intrusion lifecycle.</p>

      <h2>5: The Deeper Finding (Correlation still fails if the dataset is wrong)</h2>
      <p>When I tested the sequence, the correlation did not produce alerts; not because the concept was flawed, but because the first stage of the chain could not match. The authentication events required by the sequence were not present in the expected dataset (<code>system.auth</code> never initialized). As a result, the sequence could not complete, even though later stages (process and network telemetry) were visible.</p>
      <p>This reinforced a critical point: <span class="highlight">Stateful correlation improves detection, but it still depends on correct, validated telemetry.</span> If a sequence relies on fields or datasets that don't exist in the environment, correlation logic cannot compensate.</p>

      <hr />

      <h2>Conclusion</h2>
      <p>Detection coverage does not equal detection efficacy. Attacks unfold as stories, but many SIEM detections still evaluate sentences in isolation; and sometimes, they evaluate the wrong book entirely. Until detections retain state across identity, endpoint, and network telemetry and teams validate that the underlying data model matches real execution, <span class="highlight">silence will continue to look like safety.</span></p>

      <hr />

      <section class="project-gallery">
        <h2>Screenshots</h2>
        <p class="muted-text">Click any image to zoom.</p>

        <div class="img-grid">
          <figure><img loading="lazy" src="/assets/project3/3.png" alt="Telemetry validation in Discover"></figure>
          <figure><img loading="lazy" src="/assets/project3/4.png" alt="Dev Tools index audit"></figure>
          <figure><img loading="lazy" src="/assets/project3/5.png" alt="Siloed telemetry analysis"></figure>
          <figure><img loading="lazy" src="/assets/project3/6.png" alt="Root cause investigation"></figure>
          <figure><img loading="lazy" src="/assets/project3/7.png" alt="Stateful EQL implementation"></figure>
          <figure><img loading="lazy" src="/assets/project3/8.png" alt="Successful detection chain"></figure>
        </div>
      </section>

      <p class="muted-text" style="margin-top:18px">
        See the quick summary on Instagram <strong>@maria.cybersec</strong>.
      </p>
    </main>
  </div>

  <div class="lightbox" id="lightbox" aria-hidden="true">
    <span class="close" id="lbClose" aria-label="Close">×</span>
    <img id="lbImg" alt="">
  </div>

  <script>
    (function(){
      const lb = document.getElementById('lightbox');
      const lbImg = document.getElementById('lbImg');
      const lbClose = document.getElementById('lbClose');
      document.querySelectorAll('.img-grid img').forEach(img=>{
        img.addEventListener('click',()=>{
          lbImg.src = img.dataset.full || img.src;
          lbImg.alt = img.alt || '';
          lb.classList.add('open');
          lb.setAttribute('aria-hidden','false');
          document.body.style.overflow = 'hidden';
        });
      });
      function closeLB(){
        lb.classList.remove('open');
        lb.setAttribute('aria-hidden','true');
        document.body.style.overflow = '';
        lbImg.src = '';
      }
      lbClose.addEventListener('click', closeLB);
      lb.addEventListener('click', e => { if (e.target === lb) closeLB(); });
      window.addEventListener('keydown', e => { if (e.key === 'Escape') closeLB(); });
    })();
  </script>
</body>
</html>
